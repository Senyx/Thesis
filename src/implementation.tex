%!TEX root = index.tex
\chapter{Implementation}

\red{TODO}

\section{Scheduling}

\red{TODO}

% \begin{algorithm}[H]
% \begin{algorithmic}
% \renewcommand{\algorithmicrequire}{\textbf{Input:}}
% \renewcommand{\algorithmicensure}{\textbf{Output:}}

% \Function{newAirplaneOnScreen}{plane}
% 	\If{plane isn't heading to the airport}
% 		\State \Return
% 	\EndIf
% 	\State \red{todo}
% \EndFunction
% \end{algorithmic}
% \caption{Processing new airplane on screen}
% \label{alg1}
% \end{algorithm}




% % -------------------------------------------------
% % Set up a new layer for the debugging marks, and make sure it is on
% % top
% \pgfdeclarelayer{marx}
% \pgfsetlayers{main,marx}
% % A macro for marking coordinates (specific to the coordinate naming
% % scheme used here). Swap the following 2 definitions to deactivate
% % marks.
% \providecommand{\cmark}[2][]{%
%   \begin{pgfonlayer}{marx}
%     \node [nmark] at (c#2#1) {#2};
%   \end{pgfonlayer}{marx}
%   } 
% \providecommand{\cmark}[2][]{\relax}


% \begin{figure}[h]
%     \centering
% \begin{tikzpicture}[
%     >=triangle 60,
%     start chain=going below,
%     node distance=6mm and 60mm,
%     every join/.style={norm},
%     ]
% % ------------------------------------------------- 
% % A few box styles 
% % <on chain> *and* <on grid> reduce the need for manual relative
% % positioning of nodes
% \tikzset{
%   base/.style={draw, on chain, on grid, align=center, minimum height=4ex},
%   proc/.style={base, rectangle, text width=8em},
%   test/.style={base, diamond, aspect=2, text width=5em},
%   term/.style={proc, rounded corners},
%   % coord node style is used for placing corners of connecting lines
%   coord/.style={coordinate, on chain, on grid, node distance=6mm and 25mm},
%   % nmark node style is used for coordinate debugging marks
%   nmark/.style={draw, cyan, circle, font={\sffamily\bfseries}},
%   % -------------------------------------------------
%   % Connector line styles for different parts of the diagram
%   norm/.style={->, draw, black},
%   it/.style={font={\small\itshape}}
% }
% \node [term, join]      {New airplane on screen};
% \node [proc, join]      {Filter applicable routes};
% \node [test, join] (t1) {Multiple applicable routes?};
% \node [proc, right=of t1]      {Open queue};
% \node [proc, left=of t1]      {Dispatch message};
% % No join for exits from test nodes - connections have more complex
% % requirements
% % We continue until all the blocks are positioned
% \node [proc] (p2) {$k \mathbin{{-}{=}} 1$};
% \node [proc, join] (p3) {Dispatch message};
% \node [test, join] (t2) {Got msg?};
% \node [test] (t3) {Capacity?};
% \node [test] (t4) {$k \mathbin{{-}{=}} 1$};
% % We position the next block explicitly as the first block in the
% % second column.  The chain 'comes along with us'. The distance
% % between columns has already been defined, so we don't need to
% % specify it.
% \node [proc, fill=black!25, right=of p1] (p4) {Reset congestion};
% \node [proc, join=by norm] {Set \textsc{mq} wait flag};
% \node [proc, join=by norm] (p5) {Dispatch message};
% \node [test, join=by norm] (t5) {Got msg?};
% \node [test] (t6) {Capacity?};
% % Some more nodes specifically positioned (we could have avoided this,
% % but try it and you'll see the result is ugly).
% \node [test] (t7) [right=of t2] {$k \mathbin{{-}{=}} 1$};
% \node [proc, fill=black!25, right=of t3] (p8) {Set congestion};
% \node [proc, join=by norm, right=of t4] (p9) {Close queue};
% \node [term, join] (p10) {Exit trigger message thread};
% % -------------------------------------------------
% % Now we place the coordinate nodes for the connectors with angles, or
% % with annotations. We also mark them for debugging.
% \node [coord, right=of t1] (c1)  {}; \cmark{1}   
% \node [coord, right=of t3] (c3)  {}; \cmark{3}   
% \node [coord, right=of t6] (c6)  {}; \cmark{6}   
% \node [coord, right=of t7] (c7)  {}; \cmark{7}   
% \node [coord, left=of t4]  (c4)  {}; \cmark{4}   
% \node [coord, right=of t4] (c4r) {}; \cmark[r]{4}
% \node [coord, left=of t7]  (c5)  {}; \cmark{5}   
% \end{tikzpicture}
%     \caption{Example of runway plan with colliding slots}
%     \label{fig:TEST}
% \end{figure}

% \begin{tikzpicture}[%
%     >=triangle 60,              % Nice arrows; your taste may be different
%     start chain=going below,    % General flow is top-to-bottom
%     node distance=6mm and 60mm, % Global setup of box spacing
%     every join/.style={norm},   % Default linetype for connecting boxes
%     ]
% % ------------------------------------------------- 
% % A few box styles 
% % <on chain> *and* <on grid> reduce the need for manual relative
% % positioning of nodes
% \tikzset{
%   base/.style={draw, on chain, on grid, align=center, minimum height=4ex},
%   proc/.style={base, rectangle, text width=8em},
%   test/.style={base, diamond, aspect=2, text width=5em},
%   term/.style={proc, rounded corners},
%   % coord node style is used for placing corners of connecting lines
%   coord/.style={coordinate, on chain, on grid, node distance=6mm and 25mm},
%   % nmark node style is used for coordinate debugging marks
%   nmark/.style={draw, cyan, circle, font={\sffamily\bfseries}},
%   % -------------------------------------------------
%   % Connector line styles for different parts of the diagram
%   norm/.style={->, draw, black},
%   it/.style={font={\small\itshape}}
% }
% % -------------------------------------------------
% % Start by placing the nodes
% \node [proc, densely dotted, it] (p0) {New trigger message thread};
% % Use join to connect a node to the previous one 
% \node [term, join]      {Trigger scheduler};
% \node [proc, join] (p1) {Get quota $k > 1$};
% \node [proc, join]      {Open queue};
% \node [proc, join]      {Dispatch message};
% \node [test, join] (t1) {Got msg?};
% % No join for exits from test nodes - connections have more complex
% % requirements
% % We continue until all the blocks are positioned
% \node [proc] (p2) {$k \mathbin{{-}{=}} 1$};
% \node [proc, join] (p3) {Dispatch message};
% \node [test, join] (t2) {Got msg?};
% \node [test] (t3) {Capacity?};
% \node [test] (t4) {$k \mathbin{{-}{=}} 1$};
% % We position the next block explicitly as the first block in the
% % second column.  The chain 'comes along with us'. The distance
% % between columns has already been defined, so we don't need to
% % specify it.
% \node [proc, fill=black!25, right=of p1] (p4) {Reset congestion};
% \node [proc, join=by norm] {Set \textsc{mq} wait flag};
% \node [proc, join=by norm] (p5) {Dispatch message};
% \node [test, join=by norm] (t5) {Got msg?};
% \node [test] (t6) {Capacity?};
% % Some more nodes specifically positioned (we could have avoided this,
% % but try it and you'll see the result is ugly).
% \node [test] (t7) [right=of t2] {$k \mathbin{{-}{=}} 1$};
% \node [proc, fill=black!25, right=of t3] (p8) {Set congestion};
% \node [proc, join=by norm, right=of t4] (p9) {Close queue};
% \node [term, join] (p10) {Exit trigger message thread};
% % -------------------------------------------------
% % Now we place the coordinate nodes for the connectors with angles, or
% % with annotations. We also mark them for debugging.
% \node [coord, right=of t1] (c1)  {}; \cmark{1}   
% \node [coord, right=of t3] (c3)  {}; \cmark{3}   
% \node [coord, right=of t6] (c6)  {}; \cmark{6}   
% \node [coord, right=of t7] (c7)  {}; \cmark{7}   
% \node [coord, left=of t4]  (c4)  {}; \cmark{4}   
% \node [coord, right=of t4] (c4r) {}; \cmark[r]{4}
% \node [coord, left=of t7]  (c5)  {}; \cmark{5}   
% % -------------------------------------------------
% % A couple of boxes have annotations
% \node [above=0mm of p4, it] {(Queue was empty)};
% \node [above=0mm of p8, it] {(Queue was not empty)};
% % -------------------------------------------------
% % All the other connections come out of tests and need annotating
% % First, the straight north-south connections. In each case, we first
% % draw a path with a (consistently positioned) annotation node, then
% % we draw the arrow itself.
% \path (t1.south) to node [near start, xshift=1em] {$y$} (p2);
%   \draw [*->,black] (t1.south) -- (p2);
% \path (t2.south) to node [near start, xshift=1em] {$y$} (t3); 
%   \draw [*->,black] (t2.south) -- (t3);
% \path (t3.south) to node [near start, xshift=1em] {$y$} (t4); 
%   \draw [*->,black] (t3.south) -- (t4);
% \path (t5.south) to node [near start, xshift=1em] {$y$} (t6); 
%   \draw [*->,black] (t5.south) -- (t6);
% \path (t6.south) to node [near start, xshift=1em] {$y$} (t7); 
%   \draw [*->,black] (t6.south) -- (t7); 
% % ------------------------------------------------- 
% % Now the straight east-west connections. To provide consistent
% % positioning of the test exit annotations, we have positioned
% % coordinates for the vertical part of the connectors. The annotation
% % text is positioned on a path to the coordinate, and then the whole
% % connector is drawn to its destination box.
% \path (t3.east) to node [near start, yshift=1em] {$n$} (c3); 
%   \draw [o->,black] (t3.east) -- (p8);
% \path (t4.east) to node [yshift=-1em] {$k \leq 0$} (c4r); 
%   \draw [o->,black] (t4.east) -- (p9);
% % -------------------------------------------------
% % Finally, the twisty connectors. Again, we place the annotation
% % first, then draw the connector
% \path (t1.east) to node [near start, yshift=1em] {$n$} (c1); 
%   \draw [o->,black] (t1.east) -- (c1) -- (p4);
% \path (t2.east) -| node [very near start, yshift=1em] {$n$} (c1); 
%   \draw [o->,black] (t2.east) -| (c1);
% \path (t4.west) to node [yshift=-1em] {$k>0$} (c4); 
%   \draw [*->,black] (t4.west) -- (c4) -- (p3);
% \path (t5.east) -| node [very near start, yshift=1em] {$n$} (c6); 
%   \draw [o->,black] (t5.east) -| (c6); 
% \path (t6.east) to node [near start, yshift=1em] {$n$} (c6); 
%   \draw [o->,black] (t6.east) -| (c7); 
% \path (t7.east) to node [yshift=-1em] {$k \leq 0$} (c7); 
%   \draw [o->,black] (t7.east) -- (c7)  -- (p9);
% \path (t7.west) to node [yshift=-1em] {$k>0$} (c5); 
%   \draw [*->,black] (t7.west) -- (c5) -- (p5);
% \end{tikzpicture}






\section{STAR Application}
\subsection{Flight Plan update}
\subsection{Clearances}
\subsection{Speed}

\section{TMA to Enroute Communication}

\section{Flow Control}
\subsection{Vectoring}
\subsection{Holding Pattern}
\subsection{Miles In Trails}

\section{Runway Plan Visualization}

% přivádím až k letišti ale poslední úsek jen tak nahrubo, pak ho odřídí tower

% přesnější popis zadání - so teda chci dosáhnout

% Class B airspace Around atlanta
% vytvořeno z dostupných informací - popsat tam slovně ten tvar?
% obrázky
% vnější obvod aby seděl na dané sektory
% informace o update tvaru

% první update:
% http://www.dot.ga.gov/localgovernment/intermodalprograms/aviation/documents/classbpresentationshowformat.pdf
% http://proofofright.files.wordpress.com/2011/07/atl-class-b1.jpg

% druhý update:
% http://web.co.dekalb.ga.us/pdkairport/pdf/AirspaceArticle.pdf
% asi aktuální verze:
% https://www.federalregister.gov/articles/2012/02/03/2012-2072/proposed-modification-of-the-atlanta-class-b-airspace-area-ga !!!!!!!!!!!!!!!!!!!!!

% nejdřív zkoušení funkčnosti na doplňku, pak na class 2 airspace, protože pod ním se nacházejí další letiště (12, v okolí dalších 11) -> menší prostor -> komplikovanější



% definice samotného letiště,
% v tuhle chvíli stačí runwaye
% podle
% http://airnav.com/airport/KATL a http://155.178.201.160/d-tpp/1410/00026AD.PDF

% dát tam samotný popis runwayí, obrázek konfigurace, co jsme vyignorovali (povrch, navádění atd.), screenshot z visia 





% vytvoření nové konfigurace, vyfiltrování letů, které letí z/do/přes atlantu

% popis výběru a napasování route na FP
% jak se řeší napasování routy když jde souběžně ale po jiných fixech, viz ASQ5502_798


% eventy, skenování, radio, přeplánování, update fpi a horizontálního plánu

% porovnání s online schedullingem, kde můžou tasky čekat dokud se procesor neuvolní, ale tady se musí vykonávat od začátku, protože jinak letadlo spadne

% generování volných slotů: co nejdřívější, bere se ohled na nepřesnost odhadu ETA a marginy na obou stranách, z nichž má přednost ten delší